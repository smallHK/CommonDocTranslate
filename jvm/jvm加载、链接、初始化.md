# 加载、链接、初始化

jvm动态加载、链接与初始化类与接口。

加载是通过特定名称查找类或接口的二进制表示并且从二进制表示中创建类或接口的过程。

链接是获取类或接口将其与运行时jvm结合令其可以被执行的过程。

初始化类或接口由执行类或接口的初始化方法<clinit>完成。


## 运行时常量池

jvm为每个接口或类维护一个运行时常量池。该数据结构功能类似传统语言的符号表。类与接口的二进制表示中的constant_pool表用于在创建类或接口时，构建运行时常量池。

运行时常量池中包含两种实体：符号引用与静态常量。符号引用需要在稍后进行解析，静态常量不需要进一步的处理。

运行时常量池中的符号根据每个条目的结构，从constant_pool中的条目中派生而出。

- 对类或接口的符号引用从CONSTANT_Class_info中结构中派生而来

(派生的结果类似于Class.getName)

- 对类或接口的字段的符号引用从CONSTANT_Fieldref_info派生而来。该种引用给定字段的名称与描述符，以及该字段所属于的类或接口的符号引用。

- 对于类方法的符号引用从CONSTANT_Mehtodref_info结构中派生而来。该引用给定了方法的名称与描述符，以及该方法所属于的类的符号引用。

- CONSTANT_InterfaceMethodref_info

方法类型的符号引用从CONSTANT_MethodType_info。

动态计算常量的符号引用从CONSTANT_Dynamic_info中派生。
计算常量值的方法句柄的符号引用。
当方法句柄被调用时，作为静态参数使用的符号引用序列、静态常量序列
未限定名称与字段描述符

动态计算调用位置的符号引用从CONSTANT_InvokeDynamic_info种派生。
对方法句柄的符号引用，该方法在invokedynamic指令期间调用，用于计算java.lang.invoke.CallSite实例。
当方法句柄被调用时，作为静态参数使用的符号引用序列、静态常量序列
未限定名称与方法描述符

运行时常量池中的静态常量从constant_pool表中导出。
字符串常量为String实例的引用，从CONSTANT_String_info中派生。
数字常量从CONSTANT_Integer_info、CONSTANT_Float_info、CONSTANT_Long_info、CONSTANT_Double_info派生。

CONSTANT_NameAndType_info、CONSTANT_Module_info、CONSTANT_Package_info以及CONSTANT_Utf8_info只在构建运行时常量池时间接使用。

静态常量池中的一些实体为可载入，可以压入栈中、可以称为启动方法的静态参数。

可载入的项为：
对类与接口的符号引用
对方法句柄的符号引用
对方法类型的符号引用
对动态计算常量的符号引用
静态常量

## JVM启动

jvm通过使用启动类加载器或用户自定义类加载器创建初始类或接口进行启动。
jvm接着链接初始类或接口、实例化、调用main方法。
main方法的执行可能会链接其他类或接口、或者调用额外方法。
初始类或接口的指定依赖于实现，可以是命令行。

jvm实现也可以自己提供了初始类。


创建与载入
通过名称创建类或接口即在JVM方法区中构建类的实现特定内部表示。
当类被其他类在其自身常量池中引用时，将会触发类的创建。
类与接口的创建也可以被其他类使用SE类库中的反射等方法。

如果被创建类不是数组，可以通过使用类加载期载入类的二进制形式创建。
数组类不需要外部二进制形式。

存在两种类加载期，jvm提供的启动类加载器与用户自定义的类加载期。
所有用户自定义的类加载器都是ClassLoader的子类实例。
应用通过自定义类加载器用于扩展jvm动态加载类的方式。
用户自定义类加载器可以用于创建源自用户自定义源的类。

类加载器可以直接定义类，也可以委托给其他类加载器。

运行时，类或接口不是只由其名称决定，而是由二进制名称与定义它的的类加载器共同决定。
每一个这样的接口或类从属于单独的运行时包。
类或接口的运行时包由包名与进行定义的类加载器决定。

数组直接由jvm创建，不经过类加载器。

类加载时出错，则抛出LinkageError子类。

类加载失败时，抛出ClassNotFoundException。链接时期，发生ClassNotFoundException，会引发NoClassDefFoundError。
加载超类时的递归类加载作为解析的部分执行，所以会抛出NoClassDefFoundError。


使用启动类加载期加载
先确认是否已经加载过类，如果已经加载过，则不需要再进行创建。
jvm给启动类加载器传递类的二进制名参数。

使用用户自定义类加载器
jvm首先判断用户自定义加载器是否为已经记载过此类的初始化类加载期。
jvm调用loadClass方法。


创建数组类
数组的可访问性由组件类型的可访问类型决定。

加载约束
分别在两个不同的类加载器中加载类与接口，可能会令类名标识每个加载器中不同的类。
必须确保，类被不同的类加载器加载时，指向同一个类。
两个不同的类加载器使用不同的类相同的类名加载类之后，破坏加载约束。
jvm会在准备与解析期间强行应用约束。
jvm会在特定的时间记录特定类的初始加载器，记录之后判断是否冲突加载约束。


从class文件形式中派生类
如果类加载器已经为创建类的初始加载器，创建行为没有意义。
加载器阶段进行检查，检查class文件格式、检查class文件版本、判断class文件的类名
如果被加载类具有超类的符号引用，解析超类。
如果被加载类具有接口的符号引用，解析接口。
jvm记录初始加载器与定义加载器

模块与层
jvm允许将类与接口组织为模块。
位于模块中的类或接口的成员身份被用于控制其他模块中类或接口对它的访问。
模块身份根据运行时包定义。
程序决定每个模块中包的名称，类加载器为被命名包创建类与接口，借着指定用于ModuleLayer的defineModule方法的调用的包与类加载器。
调用defineModule用于jvm创建运行时模块以及于之关联的运行时包的类加载器。
每个运行时模块表示导出的运行时包，影响对这些包中public类与接口的访问。
每个运行时模块还可以表示其它它所读取的运行时模块，影响她自己代码对其他运行时模块中public类与接口的访问。
如果类的运行时包与模块关联，则此类位于运行时模块中。
类加载器创建的类只位与一个运行时包中，因此只位于一个运行时模块中。
通过defineModules的语义，运行时模块隐式绑定一个类加载器。即，一个类加载器可以为多个运行时模块创建类。jvm并不要求类加载器的所有运行时包都与相同的运行时模块绑定。
defineModules创建的运行时模块都是layer的一部分。
布局表示一组类加载器，用于在一组运行时模块中创建类。
存在两种布局，jvm提供的启动布局以及用户自定义布局。
启动布局由jvm以依赖实现方式启动时创建。它关联由启动类加载器定义的java.base模块中的标准运行时模块。
用户自定义布局由程序创建，用于构建一组依赖于java.base以及其他标准运行时模块的一组运行时模块。
同一个类加载器可以在不同布局中的运行时模块中创建类，因为相同的类加载器可以被用于指定调用多次defineModules。
访问控制由类的运行时模块控制，而不是创建了类的类加载器或类加载期服务的布局。
为布局制定的类加载器集合，以及作为布局一部分的运行时模块，在布局被创建之后不可变。
ModuleLayer为用户自定义布局中的运行时模块间的关系提供了一定程度上的动态控制。
如果用户自定义布局中包含超过一个类加载器，类加载器之间的委托由创建布局的程序负责。
jvm不会根据布局的运行时模块间的互相读取检验类加载的彼此委托。而且，如果布局的运行时模块通过ModuleLayer类读取额外运行时模块修改，jvm不会检验布局的类加载期类加载期是否被额外机制修改，一对应的风格委托。
类加载器与布局存在一些类似与不同的地方。布局类似于类加载器，可以委托给自己的双亲。
布局中的模块可以依赖不是自己布局中的模块，可以依赖自己双亲中的模块。
布局正能被用于创建一次新模块。
如果类加载器在运行时包中定义类一个类或接口，而此运行时包没有与类加载器服务的任意布局中的模块关联，那么类与接口将被作为一个特殊运行时模块的成员隐式绑定在类加载器上。
此特定运行时模块被称为此类加载器的未命名模块。
类加载器的为命名模块与其他运行时模块都不同。
每个未命名模块可以读取每个运行时模块。
每个未命名模块导出到每个运行时模块，每个运行时模块与自身关联。

链接

链接一个类，涉及验证准备类或接口，它的超类、超接口、元素类型（如果为一个数组类型）。
链接涉及解析类或接口中的符号引用。

链接发生：
链接之前，类或接口已经完整载入
初始化之前，类或接口已经完成验证与准备
链接期间检测到的错误将会在程序执行某些需要链接时抛出。
动态计算常量的符号引用直到ldc等引用它的指令被执行，或引用它的启动方法作为静态参数被调用时不会解析。
动态计算调用位置的符号引用直到引用它的启动方法被调用时，不会解析。
jvm实现可以选择懒惰链接策略，也可以选择积极链接策略。
但，只有当使用到被链接到的类或接口时，才会抛出链接错误。

验证
验证确保类或接口的二进制表示结构正确。
验证可能导致额外的类与接口被加载，但是不会导致它们被验证或准备。

准备
准备涉及为类或接口创建静态字段并且使用默认值初始化这些字段。
此处并不要求执行任何jvm代码。
静态字段的显示初始化作为初始化的部分执行，而不是准备。

准备阶段，jvm施加的载入约束。
载入约束，载入类重写超类、超接口的方法的参数与返回值类型，被载入类或超类的类加载期加载等价。
对于没有被重载的实例方法，选择得到的方法，其形参、返回值类型，必须与超接口声明的方法，使用各自的类加载器得到的加载情况相同。

解析

许多jvm指令依赖运行时常量池中的符号引用。
执行这些指令需要解析符号引用。
解析是动态决定符号引用从常量池中引用的具体值的过程。
首先，运行时常量池中所有的符号引用都是未解析的。

对动态计算常量的符号引用，启动方法只会被执行一次。

类与接口解析
定义类加载器使用符号引用标记的名称用于创建类或接口
应用访问控制


字段解析
解析字段引用之前，需要先解析字段类的符号引用
解析字段之前，需要先查找字段
从字段关联类、关联超接口、关联超类递归查找
确认字段之后，赋予访问控制
访问控制成功后，施加载入约束

方法解析
方法的符号引用不能来自接口
解析对应类于其超类
解析对应接口与指定类

接口方法解析


访问控制

方法重写

方法选择
在invokevirtual、invokeinterface指令执行期间，将会根据过去被此指令解析或栈上对象的运行时类型选择方法。

如果类包含实例方法的重写，使用此方法。
如果类包含超类，在超类中找寻重写的方法。
确定猜的最大确定超接口方法。


jvm退出

当一些线程调用Runtime或System的exit或Runtime的halt方法时，并且安全管理器允许执行exit与halt之后，jvm退出。


命令：Java 启动类

装载配置	根据当前路径和系统版本寻找jvm.cfg

根据配置寻找JVM.dll	JVM.dll为JVM主要实现

初始化JVM，获得JNIEnv接口	JNIEnv为JVM接口，findClass等操作通过它实现

找到main方法并运行
